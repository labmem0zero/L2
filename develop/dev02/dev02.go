package main

import (
	"fmt"
	"log"
	"strconv"
	"strings"
	"unicode"
)

func Unpack(input string)string{
	out:=""
	//Мы могли бы все сделать проще, без перевода в руны, но решено было позаботиться о любимом юникоде <3
	runed:=[]rune(input)
	var lastRune rune
	//ввод не может начинаться с неэкранированного числа
	if unicode.IsNumber(runed[0]){
		return "некорректный ввод"
	}
	//срез символов для перевода в число
	var nums []rune
	//считываем первый символ, от которого будем плясать, потому что используется переменная
	//lastRune, хранящая последний символ. Без этого на первой итерации будет получться дичь,
	//поскольку программа будет обрабатывать lastRune с нулевым значением.
	lastRune=runed[0]
	//Сразу смотрим, если первый символ является экранирующим
	escaped:=lastRune==92
	for _,c:=range runed[1:]{
		//если экранирование включено, то символ запоминается, экранирование отключается, след. итерация
		if escaped{
			lastRune=c
			escaped=false
			continue
		}
		//если считан бэкслеш, то включается экранирование и записывается в out
		//результат распаковки предидущего символа, следующая итерация
		if c==92{
			escaped=true
			out=out+runesCompose(lastRune,nums)
			continue
		}
		//если считана цифра, то она дописывается во временную переменную nums
		//для последующего перевода в число повторений символа
		//мы не проверяем, экранирована цифра или нет, т.к. проверка совершается в начале цикла
		//следующая итерация
		if unicode.IsNumber(c){
			nums=append(nums,c)
			continue
		}
		//если у нас экранирование выключено и символ не является цифрой, то в out записывается
		//результат распаковки предидущего символа, обнуляем переменную для хранения числа повторений(nums),
		//меняем обрабатываемый символ в переменной lastRune на новый, следующая итерация
		out=out+runesCompose(lastRune,nums)
		nums=[]rune{}
		lastRune=c
	}
	//после цикла необходимо еще раз записать результат распаковки символа, так как
	//в цикле это происходит только при обработке следующего.
	out=out+runesCompose(lastRune,nums)
	return out
}

//собираем символы необходимое количество раз
func runesCompose(r rune,c []rune) string{
	//важно понимать, что при нулевой длине(после распаковываемого символа не было цифр),
	//у нас должна произойти одна итерация. Поэтому в функции numberFromRune(c)
	//происходит проверка на длину
	res:=strings.Repeat(string(r),numberFromRune(c))
	return string(res)
}

//вычисляем количество повторений, полученное из последовательной записи цифр
func numberFromRune(in []rune)int{
	//проверка на длину. Цифр не было - возвращаем 1 для проведения одной итерации
	if len(in)==0{
		return 1
	}
	n,err:=strconv.Atoi(string(in))
	if err!=nil{
		log.Fatal(err)
	}
	return n
}

func main(){
	in:="a4bc2d5e"
	fmt.Println(Unpack(in))
}